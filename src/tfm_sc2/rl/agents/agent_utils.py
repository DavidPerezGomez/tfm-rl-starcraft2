import numpy as np
from pysc2.env.environment import TimeStep
from pysc2.lib.features import PlayerRelative
from tfm_sc2.rl.agents.test_agent import _PLAYER_ENEMY, FUNCTIONS
from tfm_sc2.rl.types import Position
from tfm_sc2.rl.utils import xy_locs


from typing import List


class AgentUtils:
    def get_enemy_positions(self, obs: TimeStep) -> List[Position]:
        """Get a list with all enemy positions.

        This method uses the obs.observation.feature_screen.player_relative attribute
        and filters it to keep only enemy positions.

        Args:
            obs (TimeStep): Observation to extract the feature_screen.player_relative attribute

        Returns:
            List[Position]: One Position for each enemy.
        """
        player_relative = obs.observation.feature_screen.player_relative
        enemies = self.get_positions(player_relative == PlayerRelative.ENEMY)

        return enemies

    def select_target_enemy(self, enemies: List[Position], obs: TimeStep, **kwargs):
        """Given a list of enemies, selects one of them.

        Args:
            enemies (List[Position]): List of enemies, usually obtained via self.get_enemy_positions.
            obs (TimeStep): Observation, can be used for conext or as support to make the decision.

        Returns:
            Position: The Position of the selected enemy.
        """

        # Simply return the first enemy
        return enemies[np.argmax(np.array(enemies)[:, 1])]

    def _can_do(self, function_id: int, obs: TimeStep) -> bool:
        return function_id in obs.observation.available_actions

    def can_attack(self, obs: TimeStep) -> bool:
        """Checks whether the Attack_screen action is available."""
        return self._can_do(FUNCTIONS.Attack_screen.id, obs)

    def can_select_army(self, obs: TimeStep) -> bool:
        """Checks whether the select_army action is available."""
        return self._can_do(FUNCTIONS.select_army.id, obs)

    def get_positions(self, mask: np.array) -> List[Position]:
        """Extract positions from a mask.

        Usually, the mask will be generated from a feature layer, for instance
        a set of bools generated by comparing the feature_screen.player_relative to
        some of the available flags (SELF, NEUTRAL or ENEMY).

        Args:
            mask (np.array): Mask with positions to extract

        Returns:
            List[Position]: List of positions.
        """

        # Mask should be a set of bools from comparison with a feature layer.
        y, x = mask.nonzero()
        return [Position(x, y) for x, y in zip(x, y)]

    def get_self_positions(self, obs):
        """Get a list with all "self" positions.

        This method uses the obs.observation.feature_screen.player_relative attribute
        and filters it to keep only own positions.

        Args:
            obs (TimeStep): Observation to extract the feature_screen.player_relative attribute

        Returns:
            List[Position]: One Position for each own unit/building.
        """
        player_relative = obs.observation.feature_screen.player_relative
        return self.get_positions(player_relative == PlayerRelative.SELF)

    def get_neutral_positions(self, obs):
        """Get a list with all neutral positions.

        This method uses the obs.observation.feature_screen.player_relative attribute
        and filters it to keep only neutral positions.

        Args:
            obs (TimeStep): Observation to extract the feature_screen.player_relative attribute

        Returns:
            List[Position]: One Position for each neutral unit/building/feature.
        """
        player_relative = obs.observation.feature_screen.player_relative
        return self.get_positions(player_relative == PlayerRelative.NEUTRAL)
