from typing import TYPE_CHECKING, List

import numpy as np
from pysc2.agents import base_agent
from pysc2.env.environment import TimeStep
from pysc2.lib import actions, features, units
from pysc2.lib.features import PlayerRelative

from ..types import Position


class BaseAgent(base_agent.BaseAgent):
    HARVEST_ACTIONS = [
        359, # Function.raw_ability(359, "Harvest_Gather_SCV_unit", raw_cmd_unit, 295, 3666),
        362, # Function.raw_ability(362, "Harvest_Return_SCV_quick", raw_cmd, 296, 3667),
    ]
    
    

    def select_target_enemy(self, enemies: List[Position], obs: TimeStep, **kwargs):
        """Given a list of enemies, selects one of them.

        Args:
            enemies (List[Position]): List of enemies, usually obtained via self.get_enemy_positions.
            obs (TimeStep): Observation, can be used for conext or as support to make the decision.

        Returns:
            Position: The Position of the selected enemy.
        """

        # Simply return the first enemy
        return enemies[np.argmax(np.array(enemies)[:, 1])]

    def get_enemy_positions(self, obs: TimeStep) -> List[Position]:
        """Get a list with all enemy positions.

        This method uses the obs.observation.feature_screen.player_relative attribute
        and filters it to keep only enemy positions.

        Args:
            obs (TimeStep): Observation to extract the feature_screen.player_relative attribute

        Returns:
            List[Position]: One Position for each enemy.
        """
        player_relative = obs.observation.feature_screen.player_relative
        enemies = self.get_positions(player_relative == PlayerRelative.ENEMY)

        return enemies
    
    def get_positions(self, mask: np.array) -> List[Position]:
        """Extract positions from a mask.

        Usually, the mask will be generated from a feature layer, for instance
        a set of bools generated by comparing the feature_screen.player_relative to
        some of the available flags (SELF, NEUTRAL or ENEMY).

        Args:
            mask (np.array): Mask with positions to extract

        Returns:
            List[Position]: List of positions.
        """

        # Mask should be a set of bools from comparison with a feature layer.
        y, x = mask.nonzero()
        return [Position(x, y) for x, y in zip(x, y)]

    def get_self_positions(self, obs):
        """Get a list with all "self" positions.

        This method uses the obs.observation.feature_screen.player_relative attribute
        and filters it to keep only own positions.

        Args:
            obs (TimeStep): Observation to extract the feature_screen.player_relative attribute

        Returns:
            List[Position]: One Position for each own unit/building.
        """
        player_relative = obs.observation.feature_screen.player_relative
        return self.get_positions(player_relative == PlayerRelative.SELF)

    def get_neutral_positions(self, obs):
        """Get a list with all neutral positions.

        This method uses the obs.observation.feature_screen.player_relative attribute
        and filters it to keep only neutral positions.

        Args:
            obs (TimeStep): Observation to extract the feature_screen.player_relative attribute

        Returns:
            List[Position]: One Position for each neutral unit/building/feature.
        """
        player_relative = obs.observation.feature_screen.player_relative
        return self.get_positions(player_relative == PlayerRelative.NEUTRAL)

    def can_attack(self, obs: TimeStep) -> bool:
        """Checks whether the Attack_screen action is available.

        Args:
            obs (TimeStep): An observation from the environment.

        Returns:
            bool: True if the attack action is available.
        """
        return self._can_do(features.FUNCTIONS.Attack_screen.id, obs)

    def can_select_army(self, obs: TimeStep) -> bool:
        """Checks whether the select_army action is available.

        Args:
            obs (TimeStep): An observation from the environment.

        Returns:
            bool: True if the action to select the army is available.
        """
        return self._can_do(features.FUNCTIONS.select_army.id, obs)
    
    def _can_do(self, function_id: int, obs: TimeStep) -> bool:
        """Checks whether an action can be performed.

        Args:
            function_id (int): The ID of the action.
            obs (TimeStep): An observation from the environment.

        Returns:
            bool: True if the action is available.
        """
        return function_id in obs.observation.available_actions

    def get_self_units(self, obs: TimeStep, unit_types: int | List[int] = None) -> List[features.FeatureUnit]:
        """Get a list of the player's own units.

        Args:
            obs (TimeStep): Observation from the environment
            unit_type (int | List[int], optional): Type of unit(s) to get. If provided, only units of this type(s) will be
                                       returned, otherwise all units are returned.

        Returns:
            List[features.FeatureUnit]: _description_
        """
        units = filter(lambda u: u.alliance == PlayerRelative.SELF, obs.observation.raw_units)

        if unit_types is None:
            return units
        
        if isinstance(unit_types, int):
            return filter(lambda u: u.unit_type == unit_types, units)


        return filter(lambda u: u.unit_type in unit_types, units)

    def get_idle_scvs(self, obs: TimeStep) -> List[features.FeatureUnit]:
        """Gets all idle SCVs.

        Args:
            obs (TimeStep): Observation from the environment

        Returns:
            List[features.FeatureUnit]: List of idle SCVs
        """
        self_scvs = self.get_self_units(obs, units.Terran.SCV)
        idle_scvs = filter(self_scvs, self.is_idle)

        return idle_scvs

    def get_harvester_scvs(self, obs: TimeStep) -> List[features.FeatureUnit]:
        """Get a list of all SCVs that are currently harvesting.

        Args:
            obs (TimeStep): Observation from the environment.

        Returns:
            List[features.FeatureUnit]: List of SCVs that are harvesting.
        """
        all_scvs = self.get_self_units(obs, , units.Terran.SCV)
        return filter(lambda scv: scv.order_id_0 in self.HARVEST_ACTIONS, all_scvs)

    def is_idle(self, unit: features.FeatureUnit) -> bool:
        """Check whether a unit is idle (meaning it has no orders in the queue)"""
        return unit.order_length == 0
